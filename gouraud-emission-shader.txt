Shader "Custom/GouraudEmission" {
    Properties {
        _Color ("Color", Color) = (1,1,1,1)
        _MainTex ("Albedo (RGB)", 2D) = "white" {}
        _EmissionMap ("Emission Map", 2D) = "black" {}
        _EmissionColor ("Emission Color", Color) = (0,0,0,1)
        _EmissionIntensity ("Emission Intensity", Range(0,10)) = 1.0
        _EmissionUVSet ("Emission UV Set", Range(0,1)) = 0.0
        _Glossiness ("Smoothness", Range(0,1)) = 0.5
        _Metallic ("Metallic", Range(0,1)) = 0.0
    }
    SubShader {
        Tags { "RenderType"="Opaque" }
        LOD 200

        Pass {
            Tags { "LightMode"="ForwardBase" }
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma multi_compile_fwdbase
            #pragma multi_compile_fog
            #pragma multi_compile _ VERTEXLIGHT_ON
            
            #include "UnityCG.cginc"
            #include "UnityLightingCommon.cginc"
            #include "AutoLight.cginc"

            struct appdata {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float2 uv : TEXCOORD0;
                float2 uv2 : TEXCOORD1;
            };

            struct v2f {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
                float2 uv2 : TEXCOORD1;
                fixed4 color : COLOR0;
                UNITY_FOG_COORDS(2)
            };

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            sampler2D _EmissionMap;
            float4 _EmissionMap_ST;
            fixed4 _EmissionColor;
            float _EmissionIntensity;
            float _EmissionUVSet;
            half _Glossiness;
            half _Metallic;

            // Function to calculate vertex lights
            float4 CalculateVertexLights(float3 worldPos, float3 worldNormal) {
                float4 color = 0;
                
                #ifdef VERTEXLIGHT_ON
                float4 toLightX = unity_4LightPosX0 - worldPos.x;
                float4 toLightY = unity_4LightPosY0 - worldPos.y;
                float4 toLightZ = unity_4LightPosZ0 - worldPos.z;

                float4 lengthSq = toLightX * toLightX + toLightY * toLightY + toLightZ * toLightZ;
                float4 atten = 1.0 / (1.0 + lengthSq * unity_4LightAtten0);

                float4 ndotl = 0;
                ndotl.x = max(0, dot(worldNormal, normalize(float3(toLightX.x, toLightY.x, toLightZ.x))));
                ndotl.y = max(0, dot(worldNormal, normalize(float3(toLightX.y, toLightY.y, toLightZ.y))));
                ndotl.z = max(0, dot(worldNormal, normalize(float3(toLightX.z, toLightY.z, toLightZ.z))));
                ndotl.w = max(0, dot(worldNormal, normalize(float3(toLightX.w, toLightY.w, toLightZ.w))));

                float4 spec = 0;
                float3 viewDir = normalize(WorldSpaceViewDir(float4(worldPos, 1)));
                
                for(int i = 0; i < 4; i++) {
                    float3 lightDir = normalize(float3(toLightX[i], toLightY[i], toLightZ[i]));
                    float3 halfDir = normalize(lightDir + viewDir);
                    float nh = max(0, dot(worldNormal, halfDir));
                    spec[i] = pow(nh, _Glossiness * 128.0) * _Metallic;
                }

                color.rgb = unity_LightColor[0].rgb * (ndotl.x * atten.x) +
                           unity_LightColor[1].rgb * (ndotl.y * atten.y) +
                           unity_LightColor[2].rgb * (ndotl.z * atten.z) +
                           unity_LightColor[3].rgb * (ndotl.w * atten.w);
                           
                color.rgb += unity_LightColor[0].rgb * (spec.x * atten.x) +
                            unity_LightColor[1].rgb * (spec.y * atten.y) +
                            unity_LightColor[2].rgb * (spec.z * atten.z) +
                            unity_LightColor[3].rgb * (spec.w * atten.w);
                #endif

                return color;
            }

            v2f vert (appdata v) {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                o.uv2 = TRANSFORM_TEX(v.uv2, _EmissionMap);

                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                float3 worldNormal = UnityObjectToWorldNormal(v.normal);
                
                // Main directional light
                float3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);
                float nl = max(0, dot(worldNormal, worldLightDir));
                
                // Specular for main light
                float3 viewDir = normalize(WorldSpaceViewDir(v.vertex));
                float3 halfDir = normalize(worldLightDir + viewDir);
                float nh = max(0, dot(worldNormal, halfDir));
                float spec = pow(nh, _Glossiness * 128.0) * _Metallic;
                
                // Calculate main light contribution
                o.color = UNITY_LIGHTMODEL_AMBIENT; // Start with ambient
                o.color += _LightColor0 * nl; // Add diffuse
                o.color += _LightColor0 * spec; // Add specular
                
                // Add vertex lights
                o.color += CalculateVertexLights(worldPos, worldNormal);
                
                UNITY_TRANSFER_FOG(o, o.pos);
                return o;
            }
            
            fixed4 frag (v2f i) : SV_Target {
                fixed4 albedo = tex2D(_MainTex, i.uv) * _Color;
                
                // Sample emission
                float2 emissionUV = lerp(i.uv, i.uv2, round(_EmissionUVSet));
                fixed4 emission = tex2D(_EmissionMap, emissionUV) * _EmissionColor * _EmissionIntensity;
                
                // Final color
                fixed4 c;
                c.rgb = albedo.rgb * i.color.rgb + emission.rgb;
                c.a = albedo.a;
                
                UNITY_APPLY_FOG(i.fogCoord, c);
                return c;
            }
            ENDCG
        }
        
        // Add shadow pass
        Pass {
            Tags {"LightMode"="ShadowCaster"}
            
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma multi_compile_shadowcaster
            #include "UnityCG.cginc"
            
            struct v2f {
                V2F_SHADOW_CASTER;
            };
            
            v2f vert(appdata_base v) {
                v2f o;
                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
                return o;
            }
            
            float4 frag(v2f i) : SV_Target {
                SHADOW_CASTER_FRAGMENT(i)
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}
